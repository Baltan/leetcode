package leetcode.algorithms;

import java.util.*;

/**
 * Description: 1976. Number of Ways to Arrive at Destination
 *
 * @author Baltan
 * @date 2023/1/27 13:44
 */
public class CountPaths {
    public static void main(String[] args) {
        System.out.println(countPaths(7, new int[][]{{0, 6, 7}, {0, 1, 2}, {1, 2, 3}, {1, 3, 3}, {6, 3, 3}, {3, 5, 1}, {6, 5, 1}, {2, 5, 1}, {0, 4, 5}, {4, 6, 2}}));
        System.out.println(countPaths(2, new int[][]{{1, 0, 10}}));
        System.out.println(countPaths(35, new int[][]{{1, 0, 688}, {0, 2, 548}, {0, 3, 1670}, {3, 1, 982}, {4, 3, 802}, {4, 0, 2472}, {2, 4, 1924}, {4, 1, 1784}, {5, 2, 2439}, {6, 4, 6410}, {6, 5, 5895}, {1, 6, 8194}, {6, 0, 8882}, {3, 6, 7212}, {7, 3, 9738}, {7, 2, 10860}, {6, 8, 12479}, {5, 8, 18374}, {8, 0, 21361}, {8, 4, 18889}, {7, 8, 9953}, {4, 9, 5303}, {10, 2, 11677}, {10, 0, 12225}, {10, 5, 9238}, {10, 4, 9753}, {11, 2, 28278}, {1, 11, 28138}, {6, 11, 19944}, {0, 11, 28826}, {11, 7, 17418}, {11, 3, 27156}, {10, 11, 16601}, {11, 9, 21051}, {8, 11, 7465}, {3, 12, 8839}, {13, 4, 33131}, {13, 1, 34915}, {13, 7, 24195}, {12, 13, 25094}, {9, 13, 27828}, {13, 11, 6777}, {13, 0, 35603}, {13, 5, 32616}, {6, 13, 26721}, {8, 13, 14242}, {14, 1, 32845}, {3, 14, 31863}, {11, 14, 4707}, {0, 14, 33533}, {2, 14, 32985}, {8, 14, 12172}, {15, 2, 36729}, {15, 3, 35607}, {15, 8, 15916}, {14, 15, 3744}, {0, 15, 37277}, {13, 15, 1674}, {15, 5, 34290}, {15, 12, 26768}, {16, 1, 45635}, {16, 5, 43336}, {9, 16, 38548}, {16, 6, 37441}, {7, 16, 34915}, {0, 16, 46323}, {10, 16, 34098}, {15, 16, 9046}, {16, 4, 43851}, {2, 16, 45775}, {8, 16, 24962}, {16, 14, 12790}, {17, 16, 445}, {13, 17, 11165}, {17, 15, 9491}, {2, 17, 46220}, {14, 17, 13235}, {5, 17, 43781}, {6, 17, 37886}, {12, 17, 36259}, {1, 17, 46080}, {3, 17, 45098}, {17, 8, 25407}, {17, 11, 17942}, {18, 4, 48255}, {2, 18, 50179}, {18, 1, 50039}, {18, 7, 39319}, {6, 18, 41845}, {18, 5, 47740}, {16, 18, 4404}, {3, 18, 49057}, {11, 18, 21901}, {8, 18, 29366}, {18, 17, 3959}, {4, 19, 56554}, {15, 19, 21749}, {19, 18, 8299}, {17, 19, 12258}, {19, 16, 12703}, {19, 3, 57356}, {19, 6, 50144}, {8, 19, 37665}, {2, 19, 58478}, {7, 19, 47618}, {10, 19, 46801}, {19, 13, 23423}, {19, 0, 59026}, {19, 5, 56039}, {19, 1, 58338}, {14, 19, 25493}, {10, 20, 52670}, {20, 1, 64207}, {19, 20, 5869}, {20, 14, 31362}, {20, 3, 63225}, {20, 4, 62423}, {5, 20, 61908}, {18, 20, 14168}, {16, 20, 18572}, {20, 13, 29292}, {20, 6, 56013}, {21, 14, 21724}, {21, 7, 43849}, {16, 21, 8934}, {10, 21, 43032}, {21, 9, 47482}, {12, 21, 44748}, {16, 22, 14568}, {8, 22, 39530}, {22, 19, 1865}, {17, 22, 14123}, {9, 22, 53116}, {23, 4, 71660}, {23, 22, 13241}, {16, 23, 27809}, {23, 20, 9237}, {6, 23, 65250}, {23, 21, 18875}, {19, 23, 15106}, {23, 2, 73584}, {15, 23, 36855}, {18, 23, 23405}, {23, 17, 27364}, {13, 23, 38529}, {12, 23, 63623}, {23, 14, 40599}, {24, 23, 5515}, {5, 24, 76660}, {8, 24, 58286}, {9, 25, 76255}, {25, 17, 37262}, {18, 25, 33303}, {16, 25, 37707}, {25, 7, 72622}, {12, 25, 73521}, {25, 8, 62669}, {0, 25, 84030}, {2, 25, 83482}, {25, 10, 71805}, {25, 15, 46753}, {11, 25, 55204}, {25, 14, 50497}, {5, 25, 81043}, {25, 1, 83342}, {22, 25, 23139}, {25, 23, 9898}, {13, 25, 48427}, {20, 25, 19135}, {21, 25, 28773}, {12, 26, 78240}, {26, 9, 80974}, {19, 26, 29723}, {26, 0, 88749}, {26, 20, 23854}, {21, 26, 33492}, {7, 26, 77341}, {8, 26, 67388}, {26, 25, 4719}, {26, 5, 85762}, {26, 23, 14617}, {24, 26, 9102}, {27, 19, 3874}, {13, 27, 27297}, {0, 27, 62900}, {27, 22, 2009}, {12, 28, 82113}, {28, 6, 83740}, {28, 14, 59089}, {19, 28, 33596}, {13, 28, 57019}, {28, 15, 55345}, {28, 7, 81214}, {1, 28, 91934}, {28, 9, 84847}, {28, 26, 3873}, {11, 28, 63796}, {28, 0, 92622}, {5, 29, 90709}, {29, 28, 1074}, {29, 12, 83187}, {27, 29, 30796}, {16, 29, 47373}, {29, 18, 42969}, {22, 29, 32805}, {9, 29, 85921}, {29, 1, 93008}, {4, 29, 91224}, {15, 30, 58622}, {30, 6, 87017}, {21, 30, 40642}, {4, 30, 93427}, {8, 30, 74538}, {30, 12, 85390}, {28, 30, 3277}, {3, 30, 94229}, {30, 26, 7150}, {30, 0, 95899}, {30, 29, 2203}, {30, 13, 60296}, {30, 9, 88124}, {7, 30, 84491}, {18, 30, 45172}, {30, 2, 95351}, {16, 30, 49576}, {30, 1, 95211}, {31, 30, 7302}, {4, 31, 100729}, {9, 31, 95426}, {31, 14, 69668}, {31, 10, 90976}, {13, 31, 67598}, {31, 7, 91793}, {32, 2, 96160}, {26, 32, 7959}, {21, 32, 41451}, {9, 32, 88933}, {29, 32, 3012}, {32, 0, 96708}, {32, 6, 87826}, {13, 32, 61105}, {30, 32, 809}, {32, 3, 95038}, {5, 32, 93721}, {32, 8, 75347}, {10, 32, 84483}, {20, 32, 31813}, {32, 15, 59431}, {11, 32, 67882}, {32, 19, 37682}, {28, 32, 4086}, {7, 32, 85300}, {18, 32, 45981}, {12, 32, 86199}, {25, 32, 12678}, {4, 32, 94236}, {32, 22, 35817}, {32, 23, 22576}, {17, 32, 49940}, {32, 24, 17061}, {3, 33, 101663}, {27, 33, 40433}, {7, 33, 91925}, {33, 26, 14584}, {33, 11, 74507}, {33, 15, 66056}, {9, 33, 95558}, {33, 1, 102645}, {21, 33, 48076}, {33, 4, 100861}, {22, 33, 42442}, {20, 33, 38438}, {33, 19, 44307}, {6, 33, 94451}, {33, 31, 132}, {33, 29, 9637}, {18, 33, 52606}, {33, 16, 57010}, {5, 33, 100346}, {17, 33, 56565}, {33, 0, 103333}, {32, 33, 6625}, {14, 33, 69800}, {30, 33, 7434}, {18, 34, 55103}, {1, 34, 105142}, {34, 0, 105830}, {19, 34, 46804}, {23, 34, 31698}, {34, 25, 21800}, {34, 32, 9122}, {34, 6, 96948}, {34, 5, 102843}, {34, 3, 104160}, {27, 34, 42930}, {34, 11, 77004}, {34, 22, 44939}, {33, 34, 2497}, {8, 34, 84469}, {34, 13, 70227}, {24, 34, 26183}, {34, 7, 94422}, {12, 34, 95321}, {31, 34, 2629}, {34, 16, 59507}, {34, 2, 105282}, {34, 20, 40935}, {28, 34, 13208}}));
    }

    public static int countPaths(int n, int[][] roads) {
        int mod = 1000000007;
        /**
         * 堆优化Dijkstra，times[i]表示从路口0到路口i的最小用时
         * @see CountRestrictedPaths
         */
        long[] times = new long[n + 1];
        /**
         * plans[i]表示从路口0到路口i最小用时的方案数
         */
        long[] plans = new long[n + 1];
        /**
         * graphs[i]为和路口i直接相连的道路的列表
         */
        List<Road>[] graphs = new List[n];
        /**
         * 保存到达的每个路口，并且按照属性"从路口0到当前路口的最小用时"升序排列
         */
        Queue<Integer> queue = new PriorityQueue<>(Comparator.comparingLong(x -> times[x]));
        /**
         * isVisited[i]表示从路口0到路口i的最小用时已计算过
         */
        boolean[] isVisited = new boolean[n + 1];
        Arrays.fill(times, Long.MAX_VALUE);
        /**
         * 从路口0到达路口0用时为0，方案数为1
         */
        times[0] = 0;
        queue.offer(0);
        plans[0] = 1;

        for (int i = 0; i < n; i++) {
            graphs[i] = new ArrayList<>();
        }
        /**
         * 构建有向图
         */
        for (int[] road : roads) {
            int x = road[0];
            int y = road[1];
            int time = road[2];
            graphs[x].add(new Road(y, time));
            graphs[y].add(new Road(x, time));
        }

        while (!queue.isEmpty()) {
            int from = queue.poll();

            if (isVisited[from]) {
                continue;
            }
            isVisited[from] = true;
            /**
             * 遍历从start出发的所有道路，判断是否能缩短从路口0到达下一路口的总用时
             */
            for (Road road : graphs[from]) {
                int to = road.to;
                long nextTime = times[from] + road.time;

                if (nextTime == times[to]) {
                    plans[to] = (plans[to] + plans[from]) % mod;
                } else if (nextTime < times[to]) {
                    plans[to] = plans[from];
                    times[to] = nextTime;
                }
                queue.offer(to);
            }
            /**
             * 只要计算得到了plans[n-1]就可以结束了，不需要计算出节点0到达每个节点的最小用时方案数
             */
            if (from == n - 1) {
                break;
            }
        }
        return (int) plans[n - 1];
    }

    /**
     * 道路信息类
     */
    public static class Road {
        /**
         * 下一路口
         */
        private int to;
        /**
         * 通过道路的时间
         */
        private int time;

        public Road(int to, int time) {
            this.to = to;
            this.time = time;
        }
    }
}
