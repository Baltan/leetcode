package leetcode.algorithms;

import java.util.HashMap;
import java.util.Map;

/**
 * Description: 2584. Split the Array to Make Coprime Products
 *
 * @author Baltan
 * @date 2023/3/5 18:32
 */
public class FindValidSplit {
    public static void main(String[] args) {
        System.out.println(findValidSplit(new int[]{13879, 383651, 65843, 293087, 558091, 645329, 333049, 753197, 857341, 859181, 35831, 116471, 888163, 957331, 515777, 142787, 762779, 266111, 169987, 89083, 451699, 376837, 856927, 517277, 628423, 541231, 781423, 585877, 54647, 474809, 526387, 556817, 337817, 655643, 431447, 245279, 873739, 357817, 13879, 713681, 871901, 765169, 511211, 418007, 497111, 12517, 379343, 358811, 351643, 674677, 688747, 826349, 805031, 529051, 923833, 488603, 403703, 293087, 410087, 180137, 928637, 776453, 394187, 707159, 184013, 126079, 57149, 683653, 652541, 156671, 55817, 89083, 110569, 21851, 782329, 610733, 867151, 559067, 247381, 412147, 475273, 554759, 825413, 181243, 262321, 930283, 846233, 760841, 742619, 183473, 507641, 324179, 39887, 892709, 44293, 580691, 101347, 524983, 501577, 808217, 916339, 389297, 880699, 346877, 40841, 802667, 335693, 115879, 520703, 18773, 684889, 132911, 173309, 984757, 821101, 514103, 110059, 634331, 277493, 645431, 106487, 252157, 324949, 855419, 278497, 313409, 233921, 601021, 940001, 474809, 608633, 139361, 659713, 20123, 2857, 886129, 126923, 871303, 556817, 729607, 649631, 16921, 624997, 58543, 4391, 598877, 909971, 693793, 339491, 255851, 911249, 227611, 196159, 451499, 607337, 823717, 469141, 229529, 805019, 849131, 259943, 773681, 588641, 920743, 960419, 390883, 69697, 908321, 321721, 548003, 345773, 496897, 580691, 86629, 3529, 92401, 12689, 192343, 753197, 736721, 624497, 842321, 415231, 228611, 489631, 902903, 388099, 21767, 379013, 212207, 384509, 971759, 151, 200293, 132247, 216743, 664891, 574367, 444623, 458207, 221471, 256541, 373, 286483, 607261, 34267, 868873, 677459, 503077, 700561, 23497, 952117, 116849, 381167, 84761, 17099, 563587, 421987, 258109, 939193, 290201, 454151, 257069, 134153, 742541, 854599, 833717, 444967, 965773, 55219, 655211, 370441, 68711, 334793, 897241, 308509, 516437, 731201, 887401, 746777, 803939, 309599, 502669, 31177, 285749, 89057, 744371, 273709, 100297, 87107, 423461, 93229, 445321, 129719, 998831, 933319, 795007, 970549, 338717, 74771, 502883, 108541, 872173, 840223, 124489, 19421, 407317, 134683, 64853, 143977, 567631, 626837, 835511, 133691, 476911, 904357, 103979, 550427, 749843, 903257, 844321, 952207, 351047, 635969, 467903, 617873, 648107, 380713, 418751, 112331, 550189, 384733, 58733, 416579, 228929, 543187, 154493, 106877, 503441, 777041, 229769, 809201, 332009, 24443, 305419, 660529, 103183, 456613, 233083, 76289, 345599, 269131, 96553, 126823, 776879, 527489, 912859, 867121, 347707, 854569, 98953, 879661, 253741, 578309, 885893, 581521, 762479, 321169, 298409, 717397, 197359, 111103, 714563, 351347, 239509, 752681, 429223, 559633, 558401, 485171, 636817, 239753, 855997, 897157, 545497, 131581, 831071, 664793, 875393, 574621, 521527, 205553, 459317, 46867, 784109, 793187, 546893, 85661, 969763, 621241, 642779, 713309, 198197, 135329}));
        System.out.println(findValidSplit(new int[]{4, 7, 8, 15, 3, 5}));
        System.out.println(findValidSplit(new int[]{4, 7, 15, 8, 3, 5}));
    }

    public static int findValidSplit(int[] nums) {
        int length = nums.length;
        /**
         * factorMaps[i]表示数字nums[i]分解质因数的情况
         */
        Map<Integer, Integer>[] factorMaps = new Map[length];
        /**
         * 数组nums中所有数字的乘积分解质因数的情况
         */
        Map<Integer, Integer> allFactorMap = new HashMap<>();
        /**
         * 数组nums中前缀若干个数字的乘积分解质因数的情况
         */
        Map<Integer, Integer> prefixFactorMap = new HashMap<>();

        for (int i = 0; i < length; i++) {
            factorMaps[i] = new HashMap<>();
            int num = nums[i];
            int factor = 2;
            /**
             * 对数字num分解质因数
             */
            while (num != 1) {
                if (num % factor == 0) {
                    factorMaps[i].put(factor, factorMaps[i].getOrDefault(factor, 0) + 1);
                    num /= factor;
                } else {
                    factor++;
                }
            }
        }
        /**
         * 计算数组nums中所有数字的乘积分解质因数的情况
         */
        for (Map<Integer, Integer> factorMap : factorMaps) {
            for (Map.Entry<Integer, Integer> entry : factorMap.entrySet()) {
                int factor = entry.getKey();
                int count = entry.getValue();
                allFactorMap.put(factor, allFactorMap.getOrDefault(factor, 0) + count);
            }
        }

        outer:
        for (int i = 0; i < length - 1; i++) {
            Map<Integer, Integer> factorMap = factorMaps[i];
            /**
             * 计算数组nums中索引为[0,i]的数字的乘积分解质因数的情况
             */
            for (Map.Entry<Integer, Integer> entry : factorMap.entrySet()) {
                int factor = entry.getKey();
                int count = entry.getValue();
                prefixFactorMap.put(factor, prefixFactorMap.getOrDefault(factor, 0) + count);
            }
            /**
             * 对于前缀中的每个质因数，如果所有数字乘积中的该质因数都在前缀中了，则前缀所有数字的乘积和后缀所有数字的乘积是互质的
             */
            for (Map.Entry<Integer, Integer> entry : prefixFactorMap.entrySet()) {
                int factor = entry.getKey();
                int prefixCount = entry.getValue();
                int totalCount = allFactorMap.get(factor);

                if (prefixCount < totalCount) {
                    continue outer;
                }
            }
            return i;
        }
        return -1;
    }
}
