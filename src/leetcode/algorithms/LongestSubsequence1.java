package leetcode.algorithms;

/**
 * Description: 2311. Longest Binary Subsequence Less Than or Equal to K
 *
 * @author Baltan
 * @date 2023/1/19 10:51
 * @see LongestSubsequence2
 */
public class LongestSubsequence1 {
    public static void main(String[] args) {
        System.out.println(longestSubsequence("111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", 1));
        System.out.println(longestSubsequence("000101010011011001011101111000111111100001011000000100010000111100000011111001000111100111101001111001011101001011011101001011011001111111010011100011110111010000010000010111001001111101100001111", 300429827));
        System.out.println(longestSubsequence("111100010000011101001110001111000000001011101111111110111000011111011000010101110100110110001111001001011001010011010000011111101001101000000101101001110110000111101011000101", 11713332));
        System.out.println(longestSubsequence("1001010", 5));
        System.out.println(longestSubsequence("00101001", 1));
    }

    public static int longestSubsequence(String s, int k) {
        int result = 0;
        /**
         * 当前子序列表示的二进制数字的值
         */
        long value = 0L;
        /**
         * 当前位在子序列中的权重
         */
        long weight = 1L;
        /**
         * 是否忽略剩余的1
         */
        boolean ignoreOtherOnes = false;
        char[] charArray = s.toCharArray();
        /**
         * 从字符串s的低位向高位遍历，如果某一位为0，就加在子序列的头部，因为0不会使子序列的值value发生变化；如果某一位为1，子序列头部增加了这
         * 个1后如果值value仍不大于k，就在头部增加这个1
         */
        for (int i = charArray.length - 1; i >= 0; i--) {
            int digit = charArray[i] - '0';

            if (digit == 0) {
                result++;
                weight <<= 1;
                /**
                 * 后面每一位的在子序列中的权重都大于k，说明不可能再在子序列头部追加其他1
                 */
                if (weight > k) {
                    ignoreOtherOnes = true;
                }
            } else {
                if (ignoreOtherOnes) {
                    continue;
                }

                if (value + weight <= k) {
                    result++;
                    /**
                     * 当前二进制位1使得value增大了digit*weight
                     */
                    value += weight;
                    weight <<= 1;
                } else {
                    /**
                     * 子序列的值value已经不小于k了，不可能再在子序列头部追加其他1
                     */
                    ignoreOtherOnes = true;
                }
            }
        }
        return result;
    }
}
