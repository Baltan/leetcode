package leetcode.algorithms;

/**
 * Description: 2311. Longest Binary Subsequence Less Than or Equal to K
 *
 * @author Baltan
 * @date 2023/1/19 11:12
 * @see LongestSubsequence1
 */
public class LongestSubsequence2 {
    public static void main(String[] args) {
        System.out.println(longestSubsequence("111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", 1));
        System.out.println(longestSubsequence("000101010011011001011101111000111111100001011000000100010000111100000011111001000111100111101001111001011101001011011101001011011001111111010011100011110111010000010000010111001001111101100001111", 300429827));
        System.out.println(longestSubsequence("111100010000011101001110001111000000001011101111111110111000011111011000010101110100110110001111001001011001010011010000011111101001101000000101101001110110000111101011000101", 11713332));
        System.out.println(longestSubsequence("1001010", 5));
        System.out.println(longestSubsequence("00101001", 1));
    }

    /**
     * 参考：<a href="https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/solutions/1611120/fen-lei-tao-lun-tan-xin-by-endlesscheng-vnlx/"></a>
     *
     * @param s
     * @param k
     * @return
     */
    public static int longestSubsequence(String s, int k) {
        int result = 0;
        int sLength = s.length();
        /**
         * 整型一共32位，减去k的二进制表示中前导0的个数，就是k的二进制表示的长度
         */
        int kLength = 32 - Integer.numberOfLeadingZeros(k);
        /**
         * 同为二进制表示，s的长度小于k的长度，则s的值一定小于k
         */
        if (sLength < kLength) {
            return sLength;
        }
        /**
         * 字符串s尾部长度为kLength的子串代表的二进制数的值
         */
        int sTail = Integer.parseInt(s.substring(sLength - kLength), 2);
        /**
         * 如果sTail不大于k，则字符串s尾部长度为kLength的子串都能留在最终的子序列中，否则只能留下其中的kLength-1个数
         */
        result += sTail <= k ? kLength : kLength - 1;
        /**
         * 字符串s头部长度为sLength-kLength的子串中的0都能被加在子序列的头部作为前导0，因为这些0不会改变子序列表示的数字的值
         */
        result += s.substring(0, sLength - kLength).chars().filter(c -> c == '0').count();
        return result;
    }
}
